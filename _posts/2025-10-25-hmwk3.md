---
layout: post
title: "RSA Cryptanalysis"
date: 2025-10-25 14:30:00 +01:00
author: Ludovica
---

<h2>Objective</h2>

This work repeats the cryptanalysis exercise previously done with the Caesar cipher, but this time applies RSA encryption to single letters (using very small prime numbers for didactic purposes).  
I encrypted a short text, applied two decryption methods (factorization and frequency analysis), and saved visual results for publication.

<h2>Brief Description of the Steps</h2>

<ul>
  <li><strong>Preparation:</strong> The text was encoded into numbers (A=0, …, Z=25, space=26).</li>
  <li><strong>RSA Key Generation:</strong> Two small prime numbers <em>p</em> and <em>q</em> were selected, then <em>n = p·q</em> and a public exponent <em>e</em> were computed.</li>
  <li><strong>Encryption:</strong> Each symbol was encrypted using the formula <code>c = m^e mod n</code>.</li>
  <li><strong>Method A (Practical):</strong> Factorization of <code>n</code> → computation of <code>φ(n)</code> → calculation of <code>d = e⁻¹ mod φ(n)</code> → decryption via <code>m = c^d mod n</code>.</li>
  <li><strong>Method B (Statistical):</strong> Frequency analysis of the ciphertext - attempting to map the most frequent symbols to the most frequent letters in Italian and testing for a compatible exponent <em>e</em> (using a small brute-force space).</li>
  <li><strong>Visualization:</strong> Frequency histograms (plaintext and ciphertext) and a rendered image of the decrypted text were produced and saved as images.</li>
</ul>

<h2>Detailed Steps</h2>

<ol>
  <li>
    <strong>Text Preparation and Encoding</strong><br>
    The input text was cleaned (keeping only letters and spaces), converted to numbers using the mapping A→0 … space→26, and checked to ensure all values satisfied <code>m &lt; n</code>.
  </li>

  <li>
    <strong>Key Generation and Encryption</strong><br>
    Two small primes <code>p</code> and <code>q</code> were selected, then <code>n=p·q</code> and a public exponent <code>e</code> coprime with <code>φ(n)</code> were computed.  
    Encryption was performed by applying <code>c = m**e % n</code> to each plaintext value.
  </li>

  <li>
    <strong>Method A: Factorization</strong><br>
    With small primes, factorization is trivial (trial division).  
    Once the factors were obtained, <code>φ(n)=(p-1)(q-1)</code> was computed, followed by <code>d = invmod(e, φ(n))</code>.  
    Decryption then used <code>m = c**d % n</code> for each symbol, successfully reconstructing the original message.
  </li>

  <li>
    <strong>Method B: Frequency Analysis and Search for e</strong><br>
    The ciphertext symbol frequencies were counted, and the top values were compared with the most frequent letters in Italian (E, A, I...).  
    For each hypothesis, a search for an exponent <code>e</code> was performed such that <code>pow(m, e, n) == c</code> for candidate pairs.  
    When a consistent <code>e</code> was found, the same decryption approach as Method A could be used, or <code>d</code> could be brute-forced to check for readable results.
  </li>

  <li>
    <strong>Result Visualization</strong><br>
    Three main images were generated:  
    a histogram of plaintext letter frequencies, a histogram of ciphertext symbol frequencies, and an image rendering of the decrypted text (to display it neatly on the site).
  </li>
</ol>

<h2>Visual Results</h2>

<h3>Histogram: Letter Frequency (Plaintext)</h3>
This figure shows the numerical distribution of letters in the original text (A=0... space=26). It serves as a baseline for comparing the ciphertext distribution.  
<img src="{{ site.baseurl }}//assets/images/rsa_plain_freq.png" alt="Plaintext letter frequency">


<h3>Histogram: Symbol Frequency (Ciphertext)</h3>
Here we observe the frequency distribution of numeric values produced by RSA encryption.  
Some symbols appear more frequently and are candidates for statistical mapping.  
<img src="{{ site.baseurl }}//assets/images/rsa_cipher_freq.png" alt="Ciphertext symbol frequency">


<h3>Decrypted Text (Method A)</h3>
Output from Method A (factorization → computation of <code>d</code> → decryption).  
<img src="{{ site.baseurl }}//assets/images/rsa_decrypted_text.png" alt="Decrypted text (method A)">


<h3>Quantitative Data Analysis</h3>

<p>
For completeness, the files containing the absolute letter frequencies
for both the plaintext and the ciphertext are provided below.
</p>

<img src="{{ site.baseurl }}//assets/images/plain_freq.jpg" alt="Plaintext Frequencies">
<img src="{{ site.baseurl }}//assets/images/cipher_freq.jpg" alt="Encrypted Frequencies">


<p>
These files show, for each symbol, its relative occurrence frequency. By comparing the two
distributions, it is possible to observe that—despite encryption—some linguistic patterns
remain traceable, reflecting the statistical structure of the Italian language.
</p>



<h2>Discussion</h2>

<ul>
  <li><strong>Method A</strong> is the most reliable: if <code>n</code> can be factorized (which is trivial with small primes), the private key can be recovered immediately, and the original text appears clearly. This demonstrates why RSA requires very large prime numbers in practice.</li>
  <li><strong>Method B</strong> highlights the statistical aspect: the permutation induced by RSA does not fully remove the frequency structure when the alphabet and <code>n</code> are small. However, with longer texts or larger moduli, frequency analysis becomes ineffective.</li>
</ul>


---

*Published by Ludovica*  
*October 30, 2025*
