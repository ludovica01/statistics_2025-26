---
layout: post
title: "Homework: RSA Cryptanalysis by Frequency Analysis"
date: 2025-10-28
author: Ludovica
---

# RSA Cryptanalysis by Frequency Analysis

**Brief:** repeat the homework done with Caesar cipher, but this time using **RSA on single letters** (with very small primes). Below you find a complete page: explanation of each step, two decryption methods, and a ready-to-run Python script. Put the ciphertext / public key in the indicated place and run the script locally.

---

## Notes on assumptions and encoding

- We encode letters as integers using the simple mapping:
  - `A -> 0, B -> 1, ..., Z -> 25`, space -> 26 (modify as needed).
- RSA parameters:
  - public key `(n, e)` is given.
  - ciphertext is a list of integers (each integer is the RSA encryption of one letter code).
- For didactic exercises we assume plaintext letters satisfy `m < n` (single-letter blocks).

---

## Method A — Practical: factorize `n`, compute `d`, decrypt

**Idea & why it works (short):** if `p` and `q` are small, factoring `n = p*q` is easy. From `p,q` compute `φ(n) = (p-1)(q-1)` and the private exponent `d = e^{-1} mod φ(n)`. Then decrypt by `m = c^d mod n`.

**Steps (each with short explanation):**
1. Factor `n` (find `p` and `q`) — trivial for small `n`.
2. Compute `φ(n) = (p-1)*(q-1)` — Euler totient.
3. Compute modular inverse `d = invmod(e, φ(n))` — private exponent.
4. Decrypt each ciphertext integer `c` as `m = pow(c, d, n)`.
5. Map `m` back to characters.

```python
# method_a.py
# Practical method: factor n -> compute d -> decrypt
from math import isqrt

# 1) helper: factor n (only for small n)
def factor_small_n(n):
    for a in range(2, isqrt(n) + 1):
        if n % a == 0:
            return a, n // a
    return None, None

# 2) extended gcd and modular inverse
def egcd(a, b):
    if b == 0:
        return a, 1, 0
    g, x1, y1 = egcd(b, a % b)
    return g, y1, x1 - (a // b) * y1

def invmod(a, m):
    g, x, _ = egcd(a, m)
    if g != 1:
        raise ValueError("Inverse does not exist")
    return x % m

# 3) decode helpers (mapping)
ALPHABET = {i: chr(ord('A') + i) for i in range(26)}
ALPHABET[26] = ' '  # space
CHAR_TO_NUM = {v:k for k,v in ALPHABET.items()}

def nums_to_text(nums):
    return ''.join(ALPHABET.get(n, '?') for n in nums)

def decrypt_with_factors(n, e, ciphertext_list):
    p, q = factor_small_n(n)
    if not p:
        raise ValueError("Failed to factor n (too large for this helper)")
    phi = (p - 1) * (q - 1)
    d = invmod(e, phi)
    plain_nums = [pow(c, d, n) for c in ciphertext_list]
    return nums_to_text(plain_nums), {'p': p, 'q': q, 'phi': phi, 'd': d}

# ---------- Example usage ----------
if __name__ == "__main__":
    # ======== INSERT YOUR PUBLIC KEY AND CIPHERTEXT HERE =========
    n = 391          # example: 17 * 23
    e = 3
    # ciphertext: list of integers (example placeholder)
    ciphertext = [  # fill with your numbers (one number per encrypted letter)
        148, 224, 10
    ]
    # ============================================================
    plaintext, meta = decrypt_with_factors(n, e, ciphertext)
    print("Decrypted text (method A):", plaintext)
    print("Metadata:", meta)
