---
layout: post
title: "RSA Cryptanalysis — Results (Colab)"
date: 2025-10-30
author: Ludovica
---

<h2>Obiettivo</h2>

Ripetizione dell'esercizio di crittoanalisi svolto con la cifra di Caesar, ma applicata a una cifratura RSA su singole lettere (con primi molto piccoli, didattici). L'esperimento è stato eseguito su Google Colab: ho cifrato un testo, ho applicato due metodi di decrittazione (fattorizzazione e analisi di frequenza) e ho salvato i risultati visivi per la pubblicazione.

<h2>Breve descrizione dei passaggi</h2>

<ul>
  <li><strong>Preparazione:</strong> ho codificato il testo in numeri (A=0, …, Z=25, spazio=26).</li>
  <li><strong>Generazione RSA:</strong> ho scelto due primi didattici <em>p</em> e <em>q</em>, calcolato <em>n = p·q</em> e un esponente pubblico <em>e</em>.</li>
  <li><strong>Cifratura:</strong> ogni simbolo è stato cifrato con <code>c = m^e mod n</code>.</li>
  <li><strong>Metodo A (pratico):</strong> fattorizzazione di <code>n</code> → calcolo di <code>φ(n)</code> → calcolo di <code>d = e⁻¹ mod φ(n)</code> → decrittazione <code>m = c^d mod n</code>.</li>
  <li><strong>Metodo B (statistico):</strong> analisi delle frequenze del ciphertext, tentativo di mappare i simboli più frequenti alle lettere più frequenti dell’italiano e ricerca di un esponente <em>e</em> compatibile (brute-force su spazi piccoli).</li>
  <li><strong>Visualizzazione:</strong> istogrammi di frequenza (plaintext e ciphertext) e rendering del testo decifrato salvati come immagini.</li>
</ul>

<h2>Passaggi dettagliati</h2>

<ol>
  <li>
    <strong>Preparazione del testo e codifica</strong><br>
    Ho ripulito il testo (lasciando solo lettere e spazi), l'ho convertito in numeri con la mappatura A→0 … spazio→26 e ho verificato che tutti i valori soddisfino <code>m &lt; n</code>.
  </li>

  <li>
    <strong>Creazione della chiave e cifratura</strong><br>
    Ho scelto i primi didattici <code>p</code> e <code>q</code>, calcolato <code>n=p·q</code> e selezionato <code>e</code> coprimo con <code>φ(n)</code>. Ho cifrato ogni valore del plaintext con <code>c = m**e % n</code>.
  </li>

  <li>
    <strong>Metodo A — fattorizzazione</strong><br>
    Per numeri piccoli la fattorizzazione è immediata (trial division). Con i fattori ho calcolato <code>φ(n)=(p-1)(q-1)</code>, poi <code>d = invmod(e, φ(n))</code>. La decrittazione usa <code>m = c**d % n</code> per ogni simbolo: risultato **ricostruito con successo**.
  </li>

  <li>
    <strong>Metodo B — analisi di frequenza + ricerca di e</strong><br>
    Ho contato le occorrenze dei valori nei ciphertext, selezionato i simboli top-K e ho tentato di mapparli alle lettere italiane più frequenti (es. E, A, I). Per ciascuna ipotesi ho cercato un esponente <code>e</code> che soddisfacesse le equazioni <code>pow(m, e, n) == c</code> per le coppie candidate. Se trovato un <code>e</code> consistente si può procedere come nel metodo A (calcolando <code>d</code>) o tentare un brute-force di <code>d</code> per validare la leggibilità.
  </li>

  <li>
    <strong>Visualizzazione risultati</strong><br>
    Ho generato tre immagini principali: istogramma delle frequenze del plaintext numerico, istogramma delle frequenze del ciphertext numerico e un'immagine con il testo decrittato (renderizzato come immagine per inserimento facile nel sito).
  </li>
</ol>

<h2>Risultati visivi</h2>

<h3>Istogramma: frequenza lettere (plaintext)</h3>
Questa figura mostra la distribuzione numerica delle lettere del testo originale (codifica A=0... spazio=26). Serve come baseline per confrontare la distribuzione del ciphertext.  

![Plaintext letter frequency]({{ site.baseurl }}/css/images/rsa_plain_freq.png){: .center-image }

<h3>Istogramma: frequenza simboli (ciphertext)</h3>
Qui si vede la distribuzione dei valori numerici prodotti dalla cifratura RSA. Noterai che alcuni simboli risultano più frequenti e sono i candidati per la mappatura statistica.  

![Ciphertext symbol frequency]({{ site.baseurl }}/css/images/rsa_cipher_freq.png){: .center-image }

<h3>Testo decrittato (Metodo A)</h3>
Output del metodo A (fattorizzazione → calcolo di <code>d</code> → decrittazione). Ho renderizzato il testo decrittato in immagine per inserirlo senza problemi di formattazione sul sito.  

![Decrypted text (method A)]({{ site.baseurl }}/css/images/rsa_decrypted_text.png){: .center-image }

<h2>Breve discussione</h2>

<ul>
  <li>Il <strong>Metodo A</strong> è quello affidabile: se si possono fattorizzare <code>n</code> (cosa banale per primi piccoli) si ricava immediatamente la chiave privata e il testo appare correttamente. Questo dimostra perché RSA richiede primi grandi.</li>
  <li>Il <strong>Metodo B</strong> mostra il ruolo delle statistiche: la permutazione indotta da RSA sui simboli non cancella completamente la struttura statistica quando l’alfabeto e <code>n</code> sono piccoli. Con testi più lunghi o n più grandi il metodo perde efficacia.</li>
  <li>Per il sito ho scelto di esporre solo i grafici e il testo decrittato — il codice è stato eseguito in Google Colab e i file immagine sono stati caricati nella cartella <code>css/images</code>.</li>
</ul>

<h2>File e riferimenti</h2>

<ul>
  <li>Script eseguiti in Colab: <code>method_a.py</code> e <code>method_b.py</code> (disponibili nella cartella <code>scripts/</code> della repo se vuoi fornire i file scaricabili).</li>
  <li>Immagini generate e caricate in: <code>css/images/</code> (nomi usati: <code>rsa_plain_freq.png</code>, <code>rsa_cipher_freq.png</code>, <code>rsa_decrypted_text.png</code>).</li>
</ul>

---

*Published by Ludovica*  
*October 30, 2025*
