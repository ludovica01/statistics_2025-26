"""
HMWK 1
Author: Ludovica
Course: Cybersecurity
Description:
This script simulates a server receiving weekly security updates over n weeks.
There are m attackers, each able to breach the system with probability p.
For each week:
 - If the server remains secure → score = +1
 - If the server is breached → score = -1

We generate multiple random trajectories of the server’s cumulative security score.
The simulation is compared to a random walk and analyzed against the theoretical
binomial distribution as n and m grow large.
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import binom

# --- Parameters ---
n = 20        # number of weeks
m = 1000      # number of attackers
p = 0.05      # probability that an attacker breaches the system
num_sim = 5000  # number of random trajectories to simulate

# --- Simulation ---
def simulate_server_trajectory(n, m, p):
    """
    Simulates one trajectory of the server's cumulative score over n weeks.
    Returns the final cumulative score.
    """
    scores = []
    cumulative_score = 0
    for week in range(n):
        # Check if at least one attacker breaches the system this week
        breach_occurs = np.any(np.random.rand(m) < p)
        # Assign weekly score
        weekly_score = -1 if breach_occurs else +1
        cumulative_score += weekly_score
        scores.append(cumulative_score)
    return scores

# Generate multiple trajectories
all_trajectories = [simulate_server_trajectory(n, m, p) for _ in range(num_sim)]

# Compute final scores
final_scores = [traj[-1] for traj in all_trajectories]

# --- Empirical frequency of final scores ---
unique_scores, counts = np.unique(final_scores, return_counts=True)
empirical_prob = counts / num_sim

# --- Theoretical binomial distribution ---
# In the random walk analogy:
# "Secure" = +1 → success; "Breach" = -1 → failure
# Let X = number of secure weeks → X ~ Binomial(n, (1 - breach_prob))
# Then total score = (2*X - n)
breach_prob = 1 - (1 - p)**m
secure_prob = 1 - breach_prob
x = np.arange(0, n + 1)
binom_probs = binom.pmf(x, n, secure_prob)
theoretical_scores = 2*x - n  # map binomial outcomes to random-walk totals

# --- Visualization ---
plt.figure(figsize=(10,6))
plt.bar(unique_scores, empirical_prob, width=0.8, alpha=0.6, label='Empirical Distribution')
plt.plot(theoretical_scores, binom_probs, 'r-o', label='Binomial Distribution')
plt.title(f"Server Security Random Walk Simulation\nn={n}, m={m}, p={p}")
plt.xlabel("Final Total Score")
plt.ylabel("Probability")
plt.legend()
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()

# --- Convergence Discussion (printed summary) ---
print("Simulation Summary:")
print(f"  Weeks (n): {n}")
print(f"  Attackers (m): {m}")
print(f"  Breach probability per attacker (p): {p}")
print(f"  Overall breach probability per week: {breach_prob:.4f}")
print(f"  Expected mean total score: {np.mean(final_scores):.2f}")
print(f"  Expected variance: {np.var(final_scores):.2f}")

print("\nAs n and m increase, the empirical distribution of total scores converges")
print("to the theoretical binomial form. The random walk analogy becomes stronger,")
print("and by the Central Limit Theorem, the distribution approaches a normal curve.")
