---
layout: post
title: "Deriving Simple Recurrence Formulas for Mean and Variance"
date: 2025-10-30 10:00:00 +0100
categories: statistics homework
---

# Deriving Simple Recurrence Formulas for Mean and Variance

When processing data streams or large datasets, recalculating the mean and variance from scratch for every new observation (Xₙ) is computationally inefficient [1]. Instead, we can use **recurrence (or online) formulas** that update the statistics based only on the previous statistics (for n-1 observations) and the new observation [1]. This approach simplifies the process considerably and is often essential in real-time applications [1].

### 1. Recursive Formula for the Mean (Xₙ)

The mean of n observations (Xₙ) is defined as:
<br>
<code>Mean(n) = (1/n) * Σ [Xᵢ]</code>
<br>
(Dove Σ indica la sommatoria da i=1 a n) [2].

We can separate the sum into the first $n-1$ elements and the $n$-th element (Xₙ) [2]:
<br>
<code>Mean(n) = (1/n) * [ Σ (i=1 to n-1) Xᵢ + Xₙ ]</code>
<br>

We know that the sum of the first n-1 elements is equal to (n-1) times the previous mean (X<sub>n-1</sub>) [2]:
<br>
<code>Σ (i=1 to n-1) Xᵢ = (n-1) * Mean(n-1)</code>
<br>

Substituting this back into the formula for Xₙ [2]:
<br>
<code>Mean(n) = (1/n) * [ (n-1) * Mean(n-1) + Xₙ ]</code>
<br>

To simplify, we can rewrite (n-1)/n as 1 - 1/n [3]:
<br>
<code>Mean(n) = (1 - 1/n) * Mean(n-1) + (1/n) * Xₙ</code>
<br>

Alternatively, a very simple and numerically stable recursive update can be derived by calculating the difference (or error) caused by the new observation [3]:
<br>
<code>Mean(n) = Mean(n-1) + [ Xₙ - Mean(n-1) ] / n</code>
<br>
**This final formula is the simplest recurrence relation for the mean** [3]. The term (Xₙ - X<sub>n-1</sub>) $ is the error, which is then corrected by distributing it across all n observations [3].

### 2. Recursive Formula for the Variance (Vₙ)

The variance is typically calculated using the sum of squared differences from the mean [4]. Let Sₙ be the sum of squared differences for n observations:
<br>
<code>Sₙ = Σ [ (Xᵢ - Mean(n))² ]</code>
<br>
(Dove Σ indica la sommatoria da i=1 a n) [4].

For recursive calculation, we focus on how Sₙ relates to Sₙ-1 and the new data point Xₙ. This derivation often follows **Welford’s method** to maintain numerical stability [4].

Let Sₙ-1 be the previous sum of squared differences. The new sum $S_n$ can be related to S<sub>n-1</sub> using the following update, which incorporates the previous mean (X<sub>n-1</sub>) and the new mean (Xₙ) [4, 5]:
<br>
<code>Sₙ = S(n-1) + (Xₙ - Mean(n-1)) * (Xₙ - Mean(n))</code>
<br>

While the term $(X_n - \bar{X}_n)$ can be complex to calculate recursively, we substitute the mean update formula (Xₙ = X<sub>n-1</sub> + δₙ / n, where δₙ = Xₙ - X<sub>n-1</sub> is the error) [5]:
<br>
<code>Sₙ = S(n-1) + δₙ * [ δₙ - (δₙ / n) ]</code>
<br>

Simplifying this leads to the **recurrence formula for the sum of squared differences** [5]:
<br>
<code>Sₙ = S(n-1) + [ (n-1)/n ] * (Xₙ - Mean(n-1))²</code>
<br>

Once Sₙ is calculated, the sample variance Vₙ is obtained by dividing by n-1 (for n>1) [5, 6]:
<br>
<code>Vₙ = Sₙ / (n-1)</code>
<br>

### 3. Example Code Implementation

The following Python code demonstrates the use of these recurrence formulas to calculate the mean and variance sequentially as new data arrives [6]. This implements a stable, single-pass algorithm often used in data streaming environments [6].


    import random
    def calculate_online_statistics(data_stream):
    
        n = 0 
        mean = 0.0 
        M2 = 0.0 # M2 is the sum of squares of differences (S_n) [6]

        for x in data_stream: 
            n += 1 
            if n == 1: 
                mean = x 
                M2 = 0.0 
            else: 
                # 1. Update Mean (Recurrence Formula: Mean(n) = Mean(n-1) + [ Xₙ - Mean(n-1) ] / n) [7]
                delta = x - mean 
                mean += delta / n 
                
                # 2. Update Sum of Squared Differences (Recurrence Formula for S_n) [7]
                # This is the Welford update optimized for stability:
                delta2 = x - mean 
                M2 += delta * delta2 
        
        variance = M2 / (n - 1) if n > 1 else 0.0 
        return mean, variance, n
        
        # Example usage with random data
        data = [random.randint(1, 100) for _ in range(10)]
        final_mean, final_variance, total_count = calculate_online_statistics(data) [7]

        print(f"Data Stream: {data}") [8]
        print(f"Total Observations (n): {total_count}") [8]
        print(f"Online Mean: {final_mean:.4f}") [8]
        print(f"Online Variance: {final_variance:.4f}") [8]

        # Compare with built-in functions (using numpy for comparison only) [8]
        try: 
            import numpy as np 
            np_mean = np.mean(data) 
            np_variance = np.var(data, ddof=1) # ddof=1 for sample variance [8]
            print("\n--- Verification (Numpy) ---") [8]
            print(f"Numpy Mean: {np_mean:.4f}") [8]
            print(f"Numpy Sample Variance: {np_variance:.4f}") [8]
        except ImportError: 
            pass




### 4. Expanding Measures of Location: Beyond the Mean

The Arithmetic Mean (Xₙ) is the most common measure of central tendency, and its recursive calculation is straightforward, as demonstrated above [4]. However, other **measures of location** (or averages) have been proposed, each useful under specific data circumstances. Using the appropriate measure is critical, especially in cybersecurity where data often involves outliers or non-normal distributions.

The goal remains to calculate these measures **"online,"** recalculating the statistic efficiently every time a new value (Xₙ) is added, thereby avoiding the need to store the entire dataset.

#### 4.1 The Median

The Median (M) is the middle value of a dataset, separating the higher half from the lower half.

**When is it Useful?**
The Median is highly **robust against outliers** and is preferred for **skewed distributions** (like network latency or financial income) where the Mean would be pulled excessively high or low by extreme values.

**Online Calculation:**
Calculating the Median recursively is significantly more complex than the Mean. Since the Median depends on the rank and sort order of all data points, a simple formula based only on the previous median (M<sub>n-1</sub>) and the new point (Xₙ) is **not possible**.
Instead, online median calculation typically relies on data structures like **two balanced heaps (min-heap and max-heap)** or specialized data sketches (e.g., T-Digest or Q-Digest) to efficiently track the middle elements as new data arrives.

#### 4.2 The Mode

The Mode is the value that appears most frequently in a dataset.

**When is it Useful?**
The Mode is essential for **categorical data** (e.g., protocol types, error codes) or discrete numerical data where identifying the most common event is necessary. In cybersecurity, this could identify the most frequent type of attempted attack or the most common user behavior.

**Online Calculation:**
The Mode is the simplest measure of location to calculate recursively. The update relies on tracking the frequency count of each observed value ($X_i$) and the maximum frequency observed so far.

**Online Formula Concept (Frequency Counter):**

Let F(\(X_{i}\)) be the frequency count of value \(X_{i}\), and M be the current Mode.

1.  **Update Frequency:** When a new observation Xₙ arrives, increment its count:
    \[F(Xₙ) = F(Xₙ) + 1\]
2.  **Update Mode (M):** If the new count F(Xₙ) exceeds the current maximum frequency (or the frequency of the current Mode F(M)), then Xₙ becomes the new Mode:
    \[\text{If } F(Xₙ) > F(M), \text{ then } M = Xₙ\]

This requires an efficient way to store and retrieve counts, such as a hash map or dictionary, which remains scalable for large streams of data.